# -*- coding: utf-8 -*-
"""Retail Demand Forecasting and Pricing Optimization Using Machine Learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eNV3ZhNRtyTCp5tp9TSb3W78SuBQxM-v
"""



"""** About the Dataset**

This dataset has been curated to facilitate the development of a multi-agent AI system aimed at optimizing inventory management and pricing strategies in the retail sector. By combining data from stores, warehouses, suppliers, and customers, the dataset supports advanced AI-driven applications such as demand forecasting, dynamic inventory tracking, and price optimization.

These insights enable businesses to reduce stockouts, lower holding costs, and enhance overall supply chain efficiency.

üìä **Dataset Composition**

Sales Data: Includes historical transactions, product-level sales trends, and seasonal demand variations.

Inventory Levels: Captures real-time stock status across stores and warehouses, including restocking intervals.

Supplier & Logistics Data: Provides delivery schedules, lead times, and supplier performance indicators.

Pricing & Promotions: Records historical price adjustments, discount campaigns, and corresponding customer behavior.

üéØ **Use Case Potential**

This dataset serves as a foundation for training machine learning and multi-agent systems to:

Predict future demand with high accuracy

Automate and optimize inventory replenishment

Develop intelligent pricing and promotion strategies

Improve responsiveness across the supply chain

Ensure product availability while minimizing operational inefficiencies

Description:
This project focuses on leveraging retail data to optimize inventory management and pricing strategies by uncovering key patterns in sales performance. Using a combination of statistical analysis, visualization, and data preprocessing techniques, we analyze:

Sales Quantity across different products, stores, and time periods

Pricing effects on consumer behavior and demand

The impact of promotions, seasonal events, and external factors (such as weather or economic indicators) on sales trends

Variations in demand driven by different customer segments and demand trends (e.g., increasing, stable, decreasing)

Objective:
To generate actionable insights that support:

More accurate demand forecasting

Smarter inventory replenishment

Effective price optimization

Better targeted promotional planning

Ultimately, this data-driven approach aims to enhance profitability, minimize stockouts or overstock, and improve operational efficiency in retail environments.
"""

import numpy as np  # For numerical computations and linear algebra
import pandas as pd  # For data manipulation and handling CSV files
import seaborn as sns  # For statistical data visualization
import matplotlib.pyplot as plt  # For creating static plots and charts

"""Import dataset

"""

df = pd.read_csv('demand.csv')

df.info()

df.head()

df.describe()

df.tail()

df.isnull().sum()

df.duplicated().sum()

df.shape

df.dtypes

df.columns

"""Correlation Heatmap"""

# Calculate correlation matrix
correlation_matrix = df.corr(numeric_only=True)

# Sort correlation with respect to the target variable: 'Sales Quantity'
target_corr = correlation_matrix['Sales Quantity'].sort_values(ascending=False)

# Display top correlations (absolute value above a threshold)
strong_corr = target_corr[abs(target_corr) > 0.1]

# Show correlation heatmap for numerical columns
import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))
sns.heatmap(correlation_matrix, cmap='coolwarm', annot=False, fmt=".2f")
plt.title('Correlation Heatmap')
plt.tight_layout()
plt.show()

strong_corr

numerical_cols = ['Sales Quantity', 'Price']
corr_matrix = df[numerical_cols].corr()

fig3, ax3 = plt.subplots(figsize=(6, 4))
sns.heatmap(corr_matrix, annot=True, cmap="coolwarm", fmt=".2f", ax=ax3)
ax3.set_title("Correlation Matrix")
plt.tight_layout()
plt.show()

"""visualizations part for Data"""

# Set Seaborn style for plots
sns.set_style("whitegrid")

# Plot: Distribution of Sales Quantity
plt.figure(figsize=(10, 5))
sns.histplot(data=df, x='Sales Quantity', bins=30, kde=True)
plt.title('Sales Quantity Distribution', fontsize=14)
plt.xlabel('Sales Quantity')
plt.ylabel('Frequency')
plt.tight_layout()
plt.show()

# Count plots for categorical variables
fig4, axs = plt.subplots(3, 2, figsize=(15, 12))
sns.countplot(data=df, x='Promotions', ax=axs[0, 0])
sns.countplot(data=df, x='Seasonality Factors', ax=axs[0, 1])
sns.countplot(data=df, x='External Factors', ax=axs[1, 0])
sns.countplot(data=df, x='Demand Trend', ax=axs[1, 1])
sns.countplot(data=df, x='Customer Segments', ax=axs[2, 0])

axs[0, 0].set_title("Promotion Distribution")
axs[0, 1].set_title("Seasonality Factors Distribution")
axs[1, 0].set_title("External Factors Distribution")
axs[1, 1].set_title("Demand Trend Distribution")
axs[2, 0].set_title("Customer Segments Distribution")

# Hide the last unused subplot
axs[2, 1].axis('off')
plt.tight_layout()
plt.show()

# Plot: Distribution of Product Prices
plt.figure(figsize=(10, 5))
sns.histplot(data=df, x='Price', bins=30, kde=True, color='green')
plt.title('Product Price Distribution', fontsize=14)
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.tight_layout()
plt.show()

# Plot: Promotions Impact on Sales Quantity
plt.figure(figsize=(8, 5))
sns.boxplot(data=df, x='Promotions', y='Sales Quantity', palette='coolwarm')

plt.title('Effect of Promotions on Sales Quantity', fontsize=14)
plt.xlabel('Promotions')
plt.ylabel('Sales Quantity')
plt.tight_layout()
plt.show()

# Plot: Impact of Promotions on Sales Quantity (with individual data points)
plt.figure(figsize=(8, 5))

# Boxplot to show distribution
sns.boxplot(data=df, x='Promotions', y='Sales Quantity', palette='coolwarm')

# Stripplot to show individual data points (optional enhancement)
sns.stripplot(data=df, x='Promotions', y='Sales Quantity',
              color='black', alpha=0.3, jitter=0.2)

plt.title('Impact of Promotions on Sales Quantity', fontsize=14)
plt.xlabel('Promotion Status')
plt.ylabel('Sales Quantity')
plt.tight_layout()
plt.show()

# Visualization: Effect of Seasonality Factors on Sales Quantity
plt.figure(figsize=(10, 6))
sns.boxplot(
    data=df,
    x='Seasonality Factors',
    y='Sales Quantity',
    palette='magma'
)

plt.title('Seasonality Influence on Sales Quantity', fontsize=16, fontweight='bold')
plt.xlabel('Seasonality Factors', fontsize=12)
plt.ylabel('Sales Quantity', fontsize=12)
plt.xticks(rotation=15)
plt.grid(True, axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Visualization: Sales Quantity Across Customer Segments
plt.figure(figsize=(10, 5))
sns.boxplot(
    data=df,
    x='Customer Segments',
    y='Sales Quantity',
    palette='pastel'
)

plt.title('Sales Quantity by Customer Segment', fontsize=16, fontweight='bold')
plt.xlabel('Customer Segment', fontsize=12)
plt.ylabel('Sales Quantity', fontsize=12)
plt.xticks(rotation=10)
plt.grid(True, axis='y', linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

# Visualization: Impact of External Factors on Sales Quantity
plt.figure(figsize=(10, 5))

# Compute average sales per external factor
avg_sales_by_factor = df.groupby('External Factors')['Sales Quantity'].mean().reset_index()

# Bar plot of average sales by external factors
sns.barplot(
    data=avg_sales_by_factor,
    x='External Factors',
    y='Sales Quantity',
    palette='viridis'
)

plt.title('Average Sales Quantity by External Factors', fontsize=16, fontweight='bold')
plt.xlabel('External Factors', fontsize=12)
plt.ylabel('Average Sales Quantity', fontsize=12)
plt.xticks(rotation=30)
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

# Pair plot of numeric features: Sales Quantity and Price
sns.pairplot(df[['Sales Quantity', 'Price']])
plt.suptitle("Pair Plot of Numerical Features", y=1.02)
plt.tight_layout()
plt.show()

df_daily = df.groupby('Date')['Sales Quantity'].sum().reset_index()

fig5, ax5 = plt.subplots(figsize=(12, 6))
sns.lineplot(data=df_daily, x='Date', y='Sales Quantity', ax=ax5)
ax5.set_title("Daily Sales Quantity Over Time")
plt.tight_layout()
plt.show()

# Sales by Store ID
df_store = df.groupby('Store ID')['Sales Quantity'].sum().reset_index()

fig6, ax6 = plt.subplots(figsize=(12, 5))
sns.barplot(data=df_store.sort_values(by='Sales Quantity', ascending=False), x='Store ID', y='Sales Quantity', ax=ax6)
ax6.set_title("Total Sales Quantity by Store")
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

# Pair plot of numeric features: Sales Quantity and Price
sns.pairplot(df[['Sales Quantity', 'Price']])
plt.suptitle("Pair Plot of Numerical Features", y=1.02)
plt.tight_layout()
plt.show()

# Professional Visualization: Frequency of Demand Trend Over Time
plt.figure(figsize=(12, 6))

# Count the occurrences of each demand trend per date
trend_over_time = df.groupby(['Date', 'Demand Trend']).size().reset_index(name='Count')

# Lineplot for each demand trend
sns.lineplot(
    data=trend_over_time,
    x='Date',
    y='Count',
    hue='Demand Trend',
    marker='o'
)

plt.title('Trend of Demand Categories Over Time', fontsize=16, fontweight='bold')
plt.xlabel('Date', fontsize=12)
plt.ylabel('Frequency', fontsize=12)
plt.xticks(rotation=45)
plt.legend(title='Demand Trend')
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

import plotly.express as px

# Aggregate total sales by date
sales_by_date = df.groupby('Date')['Sales Quantity'].sum().reset_index()

# Interactive line plot
fig = px.line(sales_by_date, x='Date', y='Sales Quantity',
              title='Total Sales Quantity Over Time',
              labels={'Sales Quantity': 'Sales Quantity', 'Date': 'Date'})

fig.update_layout(template='plotly_white')
fig.show()

fig = px.scatter(df, x='Price', y='Sales Quantity',
                 color='Promotions',
                 hover_data=['Store ID', 'Customer Segments'],
                 title='Price vs. Sales Quantity (Colored by Promotion)',
                 template='plotly_white')

fig.show()

df['Day'] = df['Date'].dt.day
df['Month'] = df['Date'].dt.month

pivot = df.pivot_table(values='Sales Quantity', index='Month', columns='Day', aggfunc='mean')

plt.figure(figsize=(14, 6))
sns.heatmap(pivot, cmap='YlGnBu')
plt.title("Average Sales Quantity by Day and Month")
plt.xlabel("Day of Month")
plt.ylabel("Month")
plt.tight_layout()
plt.show()

import plotly.express as px

segment_sales = df.groupby('Customer Segments')['Sales Quantity'].sum().reset_index()

fig = px.treemap(segment_sales, path=['Customer Segments'], values='Sales Quantity',
                 title='Sales Contribution by Customer Segment')
fig.show()

sun_data = df.groupby(['Promotions', 'Customer Segments'])['Sales Quantity'].sum().reset_index()

fig = px.sunburst(sun_data, path=['Promotions', 'Customer Segments'], values='Sales Quantity',
                  title='Sales Breakdown by Promotion and Customer Segment')
fig.show()

plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='Customer Segments', y='Price', palette='Set2')
plt.title("Price Distribution by Customer Segment")
plt.xlabel("Customer Segment")
plt.ylabel("Price")
plt.tight_layout()
plt.show()

g = sns.FacetGrid(df, col="External Factors", col_wrap=3, height=4)
g.map(sns.histplot, "Sales Quantity", bins=20, kde=True, color="teal")
g.fig.subplots_adjust(top=0.9)
g.fig.suptitle("Sales Quantity Distribution by External Factors")
plt.show()

"""Predictive Modeling"""

# üì¶ Data Splitting
from sklearn.model_selection import train_test_split  # For splitting the dataset into training and testing sets

# üì¶ Data Preprocessing
from sklearn.preprocessing import LabelEncoder, StandardScaler  # For encoding categorical features and scaling numeric data

# üì¶ Regression Models
from sklearn.linear_model import LinearRegression  # Simple linear regression model
from sklearn.svm import SVR  # Support Vector Regression for non-linear regression
from sklearn.neighbors import KNeighborsRegressor  # K-Nearest Neighbors regression
from sklearn.tree import DecisionTreeRegressor  # Decision Tree regression
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor  # Ensemble regressors for improved accuracy

# üì¶ Evaluation Metrics
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score  # For evaluating model performance

# üßπ Drop columns that are not useful or not suitable for model training
# These include identifiers and datetime fields
columns_to_drop = ['Product ID', 'Date', 'Store ID']
df.drop(columns=columns_to_drop, inplace=True, errors='ignore')

# üî§ Label Encoding: Convert categorical string values into numeric codes
label_encoder = LabelEncoder()

# Identify all object-type (categorical) columns
categorical_columns = df.select_dtypes(include=['object']).columns

# Apply label encoding to each categorical column
for column in categorical_columns:
    df[column] = label_encoder.fit_transform(df[column].astype(str))

# üßº Handle Missing Values
# Fill any missing numeric values with the median of each column
df.fillna(df.median(numeric_only=True), inplace=True)

# üéØ Split the dataset into features (X) and target variable (y)
# 'Sales Quantity' is assumed to be the target for prediction
X = df.drop(columns=['Sales Quantity'])
y = df['Sales Quantity']

# üß™ Split the data into training and testing sets
# 80% training data, 20% testing data, with a fixed random seed for reproducibility
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# üîÑ Feature Scaling: Standardize features to have zero mean and unit variance
scaler = StandardScaler()

# Fit the scaler on the training data and transform both train and test sets
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# üß† Define a dictionary of regression models to evaluate
models = {
    "Linear Regression": LinearRegression(),
    "Random Forest Regressor": RandomForestRegressor(),
    "Gradient Boosting Regressor": GradientBoostingRegressor(),
    "Support Vector Regressor (SVR)": SVR(),
    "K-Nearest Neighbors Regressor": KNeighborsRegressor(),
    "Decision Tree Regressor": DecisionTreeRegressor()}

# üöÄ Train and Evaluate All Models
# Store performance metrics: MAE, RMSE, and R¬≤ Score for each model
results = {}

for model_name, model in models.items():
    # Train the model on the training set
    model.fit(X_train, y_train)

    # Make predictions on the test set
    y_pred = model.predict(X_test)

    # Evaluate model performance
    mae = mean_absolute_error(y_test, y_pred)
    mse = mean_squared_error(y_test, y_pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(y_test, y_pred)

    # Store results
    results[model_name] = {
        "MAE": mae,
        "RMSE": rmse,
        "R¬≤ Score": r2
    }

# üìä Display Model Performance Metrics
print("üîç Model Performance Summary:\n")

for model_name, metrics in results.items():
    print(f"{model_name:<25} | MAE: {metrics['MAE']:.2f} | RMSE: {metrics['RMSE']:.2f} | R¬≤ Score: {metrics['R¬≤ Score']:.2%}")

# üìä Plot: Comparison of Model Performance Metrics
import matplotlib.pyplot as plt

# Convert results dictionary to DataFrame and select relevant metrics
metrics_df = pd.DataFrame(results).T
metrics_df = metrics_df[['MAE', 'RMSE', 'R¬≤ Score']]  # Ensure consistent column order

# Create bar plot for comparison
plt.figure(figsize=(10, 6))
metrics_df.plot(kind='bar', colormap='coolwarm', edgecolor='black')

# Customize plot aesthetics
plt.title('Model Performance Comparison', fontsize=16, fontweight='bold')
plt.ylabel('Metric Value', fontsize=12)
plt.xlabel('Regression Models', fontsize=12)
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.legend(title='Metrics')
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Example: Show for Random Forest
model = RandomForestRegressor()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

plt.figure(figsize=(8, 6))
sns.scatterplot(x=y_test, y=y_pred, alpha=0.6)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', label='Perfect Prediction')
plt.xlabel('Actual Sales Quantity')
plt.ylabel('Predicted Sales Quantity')
plt.title('Random Forest: Actual vs. Predicted')
plt.legend()
plt.grid(True, linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

residuals = y_test - y_pred

plt.figure(figsize=(8, 5))
sns.histplot(residuals, bins=30, kde=True, color='purple')
plt.axvline(0, color='red', linestyle='--')
plt.title("Residual Distribution")
plt.xlabel("Residual (Actual - Predicted)")
plt.ylabel("Frequency")
plt.tight_layout()
plt.show()

residual_data = []

for name, model in models.items():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    residuals = y_test - y_pred
    residual_data.append(pd.DataFrame({'Model': name, 'Residual': residuals}))

residual_df = pd.concat(residual_data)

plt.figure(figsize=(10, 6))
sns.boxplot(x='Model', y='Residual', data=residual_df, palette='Set2')
plt.title('Residual Comparison Across Models')
plt.xticks(rotation=45)
plt.grid(axis='y', linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 6))
for name, model in models.items():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    error = abs(y_test - y_pred).values
    plt.plot(error, label=name)

plt.title("Absolute Error per Test Sample")
plt.xlabel("Sample Index")
plt.ylabel("Absolute Error")
plt.legend()
plt.grid(True, linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

